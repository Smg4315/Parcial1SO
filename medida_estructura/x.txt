/medida_estructura

//main.cpp
#include <iostream>
#include <vector>
#include <limits> // Para manejo de límites de entrada
#include <memory> // Para std::unique_ptr y std::make_unique
#include "persona.h"
#include "generador.h"
#include "monitor.h" // Nuevo header para monitoreo

void mostrarMenu() {
    std::cout << "\n\n=== MENÚ PRINCIPAL ===";
    std::cout << "\n0. Crear nuevo conjunto de datos";
    std::cout << "\n1. Mostrar resumen de todas las personas";
    std::cout << "\n2. Mostrar detalle completo por índice";
    std::cout << "\n3. Buscar persona por ID";
    std::cout << "\n4. Mostrar estadísticas de rendimiento";
    std::cout << "\n5. Exportar estadísticas a CSV";
    std::cout << "\n6. Salir";
    std::cout << "\nSeleccione una opción: ";
}

int main() {
    srand(time(nullptr));
    
    // Usar unique_ptr para manejar la colección de personas
    std::unique_ptr<std::vector<Persona>> personas = nullptr;
    Monitor monitor;
    
    int opcion;
    do {
        mostrarMenu();
        std::cin >> opcion;
        
        size_t tam = 0;
        int indice;
        std::string idBusqueda;
        
        // Iniciar medición de tiempo y memoria para esta operación
        monitor.iniciar_tiempo();
        long memoria_inicio = monitor.obtener_memoria();
        
        switch(opcion) {
            case 0: {
                int n;
                std::cout << "\nIngrese el número de personas a generar: ";
                std::cin >> n;
                
                if (n <= 0) {
                    std::cout << "Error: Debe generar al menos 1 persona\n";
                    break;
                }
                
                // Generar el nuevo conjunto de datos
                personas = std::make_unique<std::vector<Persona>>(generarColeccion(n));
                tam = personas->size();
                
                double tiempo_gen = monitor.detener_tiempo();
                long memoria_gen = monitor.obtener_memoria() - memoria_inicio;
                
                std::cout << "Generadas " << tam << " personas en " 
                          << tiempo_gen << " ms, Memoria: " << memoria_gen << " KB\n";
                
                monitor.registrar("Crear datos", tiempo_gen, memoria_gen);
                break;
            }
                
            case 1: {
                if (!personas || personas->empty()) {
                    std::cout << "\nNo hay datos disponibles. Use opción 0 primero.\n";
                    break;
                }
                
                tam = personas->size();
                std::cout << "\n=== RESUMEN DE PERSONAS (" << tam << ") ===\n";
                for(size_t i = 0; i < tam; ++i) {
                    std::cout << i << ". ";
                    (*personas)[i].mostrarResumen();
                    std::cout << "\n";
                }
                
                double tiempo_mostrar = monitor.detener_tiempo();
                long memoria_mostrar = monitor.obtener_memoria() - memoria_inicio;
                monitor.registrar("Mostrar resumen", tiempo_mostrar, memoria_mostrar);
                break;
            }
                
            case 2: {
                if (!personas || personas->empty()) {
                    std::cout << "\nNo hay datos disponibles. Use opción 0 primero.\n";
                    break;
                }
                
                tam = personas->size();
                std::cout << "\nIngrese el índice (0-" << tam-1 << "): ";
                if(std::cin >> indice) {
                    if(indice >= 0 && static_cast<size_t>(indice) < tam) {
                        (*personas)[indice].mostrar();
                    } else {
                        std::cout << "Índice fuera de rango!\n";
                    }
                } else {
                    std::cout << "Entrada inválida!\n";
                    std::cin.clear();
                    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
                }
                
                double tiempo_detalle = monitor.detener_tiempo();
                long memoria_detalle = monitor.obtener_memoria() - memoria_inicio;
                monitor.registrar("Mostrar detalle", tiempo_detalle, memoria_detalle);
                break;
            }
                
            case 3: {
                if (!personas || personas->empty()) {
                    std::cout << "\nNo hay datos disponibles. Use opción 0 primero.\n";
                    break;
                }
                
                std::cout << "\nIngrese el ID a buscar: ";
                std::cin >> idBusqueda;
                
                if(const Persona* encontrada = buscarPorID(*personas, idBusqueda)) {
                    encontrada->mostrar();
                } else {
                    std::cout << "No se encontró persona con ID " << idBusqueda << "\n";
                }
                
                double tiempo_busqueda = monitor.detener_tiempo();
                long memoria_busqueda = monitor.obtener_memoria() - memoria_inicio;
                monitor.registrar("Buscar por ID", tiempo_busqueda, memoria_busqueda);
                break;
            }
                
            case 4:
                monitor.mostrar_resumen();
                break;
                
            case 5:
                monitor.exportar_csv();
                break;
                
            case 6:
                std::cout << "Saliendo...\n";
                break;
                
            default:
                std::cout << "Opción inválida!\n";
        }
        
        // Mostrar estadísticas para las operaciones principales
        if (opcion >= 0 && opcion <= 3) {
            double tiempo = monitor.detener_tiempo();
            long memoria = monitor.obtener_memoria() - memoria_inicio;
            monitor.mostrar_estadistica("Opción " + std::to_string(opcion), tiempo, memoria);
        }
        
    } while(opcion != 6);
    
    return 0;
}

//generador.cpp
#include "generador.h"
#include <cstdlib>   // rand(), srand()
#include <ctime>     // time()
#include <random>    // Generadores aleatorios modernos
#include <vector>
#include <algorithm> // Para find_if
#include <iomanip>  // para std::setw y std::setfill

// --- Bases de datos para generación realista ---

// Nombres femeninos comunes en Colombia
const std::vector<std::string> nombresFemeninos = {
    "María", "Luisa", "Carmen", "Ana", "Sofía", "Isabel", "Laura", "Andrea", "Paula", "Valentina",
    "Camila", "Daniela", "Carolina", "Fernanda", "Gabriela", "Patricia", "Claudia", "Diana", "Lucía", "Ximena"
};

// Nombres masculinos comunes en Colombia
const std::vector<std::string> nombresMasculinos = {
    "Juan", "Carlos", "José", "James", "Andrés", "Miguel", "Luis", "Pedro", "Alejandro", "Ricardo",
    "Felipe", "David", "Jorge", "Santiago", "Daniel", "Fernando", "Diego", "Rafael", "Martín", "Óscar",
    "Edison", "Sofia","Camila","Juana","Ana","Laura","Karla","Andrea","Daniela","Alejandra","Martina",
    "Nelly","María","Nestor","Trinidad","Fernanda", "Carolina", "Lina", "Gertridis"
};

// Apellidos comunes en Colombia
const std::vector<std::string> apellidos = {
    "Gómez", "Rodríguez", "Martínez", "López", "García", "Pérez", "González", "Sánchez", "Ramírez", "Torres",
    "Díaz", "Vargas", "Castro", "Ruiz", "Álvarez", "Romero", "Suárez", "Rojas", "Moreno", "Muñoz", "Valencia",
};

// Principales ciudades colombianas
const std::vector<std::string> ciudadesColombia = {
    "Bogotá", "Medellín", "Cali", "Barranquilla", "Cartagena", "Bucaramanga", "Pereira", "Santa Marta", "Cúcuta", "Ibagué",
    "Manizales", "Pasto", "Neiva", "Villavicencio", "Armenia", "Sincelejo", "Valledupar", "Montería", "Popayán", "Tunja"
};

// Implementación de funciones generadoras

std::string generarFechaNacimiento() {
    // Genera día aleatorio (1-28 para simplificar)
    int dia = 1 + rand() % 28;
    // Mes aleatorio (1-12)
    int mes = 1 + rand() % 12;
    // Año entre 1960-2010
    int anio = 1960 + rand() % 50;
    
    // Convierte a string en formato DD/MM/AAAA
    return std::to_string(dia) + "/" + std::to_string(mes) + "/" + std::to_string(anio);
}

std::string generarID() {
    static long contador = 1000000000; // ID inicial
    return std::to_string(contador++); // Incrementa después de usar
}

double randomDouble(double min, double max) {
    // Generador moderno Mersenne Twister
    static std::mt19937 generator(time(nullptr));
    // Distribución uniforme en rango [min, max]
    std::uniform_real_distribution<double> distribution(min, max);
    return distribution(generator);
}

char asignarCalendario(const std::string& id) {
    // Tomar los dos últimos dígitos del id
    if (id.length() < 2) return 'A'; // Caso borde

    int ultimos_digitos = std::stoi(id.substr(id.length() - 2));

    if (ultimos_digitos <= 39)
        return 'A';
    else if (ultimos_digitos <= 79)
        return 'B';
    else
        return 'C';
}


Persona generarPersona() {
    Persona p; // Crea una instancia de la estructura Persona
    
    // Decide aleatoriamente si es hombre o mujer
    bool esHombre = rand() % 2;
    
    // Selecciona nombre según género
    p.nombre = esHombre ? 
        nombresMasculinos[rand() % nombresMasculinos.size()] :
        nombresFemeninos[rand() % nombresFemeninos.size()];
    
    // Combina dos apellidos aleatorios
    p.apellido = apellidos[rand() % apellidos.size()] + " " + 
                 apellidos[rand() % apellidos.size()];
    
    // Genera identificadores únicos
    p.id = generarID();
    // Ciudad aleatoria de Colombia
    p.ciudadNacimiento = ciudadesColombia[rand() % ciudadesColombia.size()];
    // Ciudad de residencia
    p.ciudadResidencia = ciudadesColombia[rand() % ciudadesColombia.size()];
    // Fecha aleatoria
    p.fechaNacimiento = generarFechaNacimiento();
    // Asignar calendario según ID
    p.calendario = asignarCalendario(p.id);
    
    // --- Generación de datos económicos realistas ---
    // Ingresos entre 10 millones y 500 millones COP
    p.ingresosAnuales = randomDouble(10000000, 500000000);
    // Patrimonio entre 0 y 2 mil millones COP
    p.patrimonio = randomDouble(0, 1000000000);
    // Deudas hasta el 70% del patrimonio
    if (p.patrimonio >= 0) {
    p.deudas = randomDouble(0, p.patrimonio * 0.7);
    } else {
        p.deudas = 0; // o puedes hacerlo random entre 0 y abs(p.patrimonio)
    }
    // 70% probabilidad de ser declarante si gana > 50 millones
    p.declaranteRenta = (p.ingresosAnuales > 50000000) && (rand() % 100 > 30);
    
    return p; // Retorna la estructura completa
}

std::vector<Persona> generarColeccion(int n) {
    std::vector<Persona> personas;
    // Reserva espacio para n personas (optimización)
    personas.reserve(n);
    
    // Genera n personas y las añade al vector
    for (int i = 0; i < n; ++i) {
        personas.push_back(generarPersona());
    }
    
    return personas;
}

const Persona* buscarPorID(const std::vector<Persona>& personas, const std::string& id) {
    // Búsqueda lineal por ID (solución simple para colecciones medianas)
    for (const auto& persona : personas) {
        if (persona.id == id) { // Acceso directo al campo id
            return &persona; // Retorna dirección si encuentra coincidencia
        }
    }
    return nullptr; // Retorna nulo si no encuentra
}

//generador.h
#ifndef GENERADOR_H
#define GENERADOR_H

#include "persona.h"
#include <vector>

// --- Funciones para generación de datos aleatorios ---

// Genera fecha aleatoria entre 1960-2010
std::string generarFechaNacimiento();

// Genera ID único secuencial
std::string generarID();

// Genera número decimal en rango [min, max]
double randomDouble(double min, double max);

// Crea una persona con datos aleatorios
Persona generarPersona();

// Genera colección de n personas
std::vector<Persona> generarColeccion(int n);

// Busca persona por ID en un vector
// Retorna puntero a persona si la encuentra, nullptr si no
const Persona* buscarPorID(const std::vector<Persona>& personas, const std::string& id);

#endif // GENERADOR_H

//monitor.cpp 

//monitor.h
#ifndef MONITOR_H
#define MONITOR_H

#include <chrono>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// Clase para medir tiempo y memoria en Linux
class Monitor {
public:
    // Inicia la medición de tiempo
    void iniciar_tiempo() {
        inicio = std::chrono::high_resolution_clock::now();
    }
    
    // Detiene la medición de tiempo y devuelve milisegundos
    double detener_tiempo() {
        auto fin = std::chrono::high_resolution_clock::now();
        return std::chrono::duration_cast<std::chrono::milliseconds>(fin - inicio).count();
    }
    
    // Obtiene el consumo de memoria actual en KB usando /proc/self/statm
    long obtener_memoria() {
        // Abrir el archivo de estadísticas de memoria
        FILE* file = fopen("/proc/self/statm", "r");
        if (!file) {
            perror("Error al abrir /proc/self/statm");
            return 0;
        }
        
        long size, resident, shared, text, lib, data, dt;
        if (fscanf(file, "%ld %ld %ld %ld %ld %ld %ld", 
                   &size, &resident, &shared, &text, &lib, &data, &dt) != 7) {
            fclose(file);
            return 0;
        }
        
        fclose(file);
        
        // Obtener el tamaño de página del sistema en bytes y convertir a KB
        long page_size_bytes = sysconf(_SC_PAGESIZE);
        long page_size_kb = page_size_bytes / 1024;
        
        // Memoria residente en KB (páginas * tamaño de página en KB)
        return resident * page_size_kb;
    }
    
    // Registra estadísticas para una operación
    void registrar(const std::string& operacion, double tiempo, long memoria) {
        registros.push_back({operacion, tiempo, memoria});
        total_tiempo += tiempo;
        max_memoria = std::max(max_memoria, memoria);
    }
    
    // Muestra estadísticas de una operación
    void mostrar_estadistica(const std::string& operacion, double tiempo, long memoria) {
        std::cout << "\n[ESTADÍSTICAS] " << operacion << " - "
                  << "Tiempo: " << tiempo << " ms, "
                  << "Memoria: " << memoria << " KB\n";
    }
    
    // Muestra todas las estadísticas registradas
    void mostrar_resumen() {
        std::cout << "\n=== RESUMEN DE ESTADÍSTICAS ===";
        for (const auto& reg : registros) {
            std::cout << "\n" << reg.operacion << ": "
                      << reg.tiempo << " ms, " << reg.memoria << " KB";
        }
        std::cout << "\nTotal tiempo: " << total_tiempo << " ms";
        std::cout << "\nMemoria máxima: " << max_memoria << " KB\n";
    }
    
    // Exporta las estadísticas a un archivo CSV
    void exportar_csv(const std::string& nombre_archivo = "estadisticas.csv") {
        std::ofstream archivo(nombre_archivo);
        archivo << "Operacion,Tiempo(ms),Memoria(KB)\n";
        for (const auto& reg : registros) {
            archivo << reg.operacion << "," << reg.tiempo << "," << reg.memoria << "\n";
        }
        archivo.close();
        std::cout << "Estadísticas exportadas a " << nombre_archivo << "\n";
    }

private:
    struct Registro {
        std::string operacion;
        double tiempo;
        long memoria;
    };
    
    std::chrono::high_resolution_clock::time_point inicio;
    std::vector<Registro> registros;
    double total_tiempo = 0;
    long max_memoria = 0;
};

#endif // MONITOR_H

//persona.h
#ifndef PERSONA_H
#define PERSONA_H

#include <string>
#include <iostream>
#include <iomanip>

// Estructura que representa una persona con datos personales y fiscales
struct Persona {
    // Datos básicos de identificación
    std::string nombre;           // Nombre de pila
    std::string apellido;         // Apellidos
    std::string id;               // Identificador único
    std::string ciudadNacimiento; // Ciudad de nacimiento en Colombia
    std::string ciudadResidencia; // Ciudad de residencia en Colombia
    std::string fechaNacimiento;  // Fecha en formato DD/MM/AAAA
    
    // Datos fiscales y económicos
    double ingresosAnuales;       // Ingresos anuales en pesos colombianos
    double patrimonio;            // Valor total de bienes y activos
    double deudas;                // Deudas pendientes
    bool declaranteRenta;         // Si está obligado a declarar renta

    // Nuevo campo calendario (A/B/C)
    char calendario;

    // --- Métodos de visualización ---
    void mostrar() const;         // Muestra todos los detalles completos
    void mostrarResumen() const;  // Muestra versión compacta para listados
};

inline void Persona::mostrar() const {
    std::cout << "-------------------------------------\n";
    std::cout << "[" << id << "] Nombre: " << nombre << " " << apellido << "\n";
    std::cout << "   - Ciudad de nacimiento: " << ciudadNacimiento << "\n";
    std::cout << "   - Fecha de nacimiento: " << fechaNacimiento << "\n";
    std::cout << "   - Ciudad de residencia: " << ciudadResidencia << "\n";
    std::cout << "   - Calendario declaración: " << calendario << "\n\n";
    std::cout << std::fixed << std::setprecision(2);
    std::cout << "   - Ingresos anuales: $" << ingresosAnuales << "\n";
    std::cout << "   - Patrimonio: $" << patrimonio << "\n";
    std::cout << "   - Deudas: $" << deudas << "\n";
    std::cout << "   - Declarante de renta: " << (declaranteRenta ? "Sí" : "No") << "\n";
}

inline void Persona::mostrarResumen() const {
    std::cout << nombre << " " << apellido
              << " | " << fechaNacimiento
              << " | " << ciudadResidencia
              << " | Patrimonio: $" << std::fixed << std::setprecision(2) << patrimonio
              << " | Deudas: $" << std::fixed << std::setprecision(2) << deudas
              << " | ID: " << "[" << id << "]"
              << " | Calendario: " << calendario;
}

#endif // PERSONA_H